{"version":3,"sources":["../src/utils/schemaParser.ts","../src/utils/dependencyResolver.ts","../src/utils/permissionChecker.ts","../src/constants/index.ts","../src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Schema Parser Utility\n * Parses and validates JSON form schemas\n */\n\nimport type { FormSchema, ParsedSchema, StepConfig, FieldConfig } from '../types/schema.types';\n\n/**\n * Extract metadata from form schema\n */\nexport const extractMetadata = (schema: FormSchema) => {\n  return {\n    formId: schema.formId,\n    formTitle: schema.formTitle,\n    totalSteps: schema.totalSteps,\n    submitStrategy: schema.submitStrategy,\n    autoSaveEnabled: schema.autoSaveEnabled,\n    autoSaveInterval: schema.autoSaveInterval,\n  };\n};\n\n/**\n * Parse a single step configuration\n */\nexport const parseStep = (step: StepConfig): StepConfig => {\n  return {\n    stepId: step.stepId,\n    stepTitle: step.stepTitle,\n    fields: step.fields.map(field => ({\n      ...field,\n      required: field.required ?? false,\n      disabled: field.disabled ?? false,\n    })),\n    repeatableSections: step.repeatableSections,\n  };\n};\n\n/**\n * Build validation rules from schema\n */\nexport const buildValidationRules = (schema: FormSchema): Record<string, any> => {\n  const rules: Record<string, any> = {};\n\n  schema.steps.forEach(step => {\n    step.fields.forEach(field => {\n      const fieldKey = `step${step.stepId}.${field.fieldId}`;\n      rules[fieldKey] = {\n        required: field.required,\n        validation: field.validation,\n      };\n    });\n  });\n\n  return rules;\n};\n\n/**\n * Main schema parsing function\n */\nexport const parseFormSchema = (schema: FormSchema): ParsedSchema => {\n  return {\n    metadata: extractMetadata(schema),\n    steps: schema.steps.map(parseStep),\n    validationRules: buildValidationRules(schema),\n  };\n};\n\n/**\n * Validate schema structure\n */\nexport const validateSchema = (schema: any): schema is FormSchema => {\n  if (!schema || typeof schema !== 'object') {\n    return false;\n  }\n\n  const required = ['formId', 'formTitle', 'totalSteps', 'steps'];\n  for (const field of required) {\n    if (!(field in schema)) {\n      return false;\n    }\n  }\n\n  if (!Array.isArray(schema.steps) || schema.steps.length === 0) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Get field configuration by ID and step\n */\nexport const getFieldConfig = (\n  schema: FormSchema,\n  stepId: number,\n  fieldId: string\n): FieldConfig | null => {\n  const step = schema.steps.find(s => s.stepId === stepId);\n  if (!step) return null;\n\n  return step.fields.find(f => f.fieldId === fieldId) || null;\n};\n\n/**\n * Get all fields for a specific step\n */\nexport const getStepFields = (schema: FormSchema, stepId: number): FieldConfig[] => {\n  const step = schema.steps.find(s => s.stepId === stepId);\n  return step?.fields || [];\n};","/**\n * Dependency Resolver Utility\n * Resolves field dependencies and conditional logic\n */\n\nimport type { FieldDependency, ConditionalRule } from '../types/schema.types';\n\n/**\n * Evaluate a single field dependency\n */\nexport const evaluateDependency = (\n  dependency: FieldDependency,\n  fieldValue: any\n): boolean => {\n  const { operator, value } = dependency;\n\n  switch (operator) {\n    case 'equals':\n      return fieldValue === value;\n    case 'notEquals':\n      return fieldValue !== value;\n    case 'contains':\n      return Array.isArray(fieldValue)\n        ? fieldValue.includes(value)\n        : String(fieldValue).includes(String(value));\n    case 'greaterThan':\n      return Number(fieldValue) > Number(value);\n    case 'lessThan':\n      return Number(fieldValue) < Number(value);\n    case 'isEmpty':\n      return !fieldValue || fieldValue === '' || (Array.isArray(fieldValue) && fieldValue.length === 0);\n    case 'isNotEmpty':\n      return !!fieldValue && fieldValue !== '' && (!Array.isArray(fieldValue) || fieldValue.length > 0);\n    default:\n      return false;\n  }\n};\n\n/**\n * Evaluate multiple dependencies with AND/OR logic\n */\nexport const evaluateDependencies = (\n  dependencies: FieldDependency[],\n  formData: Record<string, any>\n): boolean => {\n  if (!dependencies || dependencies.length === 0) {\n    return true;\n  }\n\n  // Get the logic type from the first dependency (default to AND)\n  const logicType = dependencies[0]?.logicType || 'AND';\n\n  if (logicType === 'OR') {\n    return dependencies.some(dep => {\n      const fieldValue = formData[dep.fieldId];\n      return evaluateDependency(dep, fieldValue);\n    });\n  }\n\n  // AND logic (default)\n  return dependencies.every(dep => {\n    const fieldValue = formData[dep.fieldId];\n    return evaluateDependency(dep, fieldValue);\n  });\n};\n\n/**\n * Evaluate a conditional rule\n */\nexport const evaluateConditionalRule = (\n  rule: ConditionalRule | undefined,\n  formData: Record<string, any>\n): boolean => {\n  if (!rule || !rule.dependencies) {\n    return true;\n  }\n\n  return evaluateDependencies(rule.dependencies, formData);\n};\n\n/**\n * Determine if a field should be visible based on its conditional visibility rule\n */\nexport const isFieldVisible = (\n  conditionalVisibility: ConditionalRule | undefined,\n  formData: Record<string, any>\n): boolean => {\n  if (!conditionalVisibility) {\n    return true; // No rule means always visible\n  }\n\n  const conditionMet = evaluateConditionalRule(conditionalVisibility, formData);\n\n  // If action is 'show', return true when condition is met\n  // If action is 'hide', return false when condition is met\n  return conditionalVisibility.action === 'show' ? conditionMet : !conditionMet;\n};\n\n/**\n * Determine if a field should be required based on its conditional required rule\n */\nexport const isFieldRequired = (\n  baseRequired: boolean,\n  conditionalRequired: ConditionalRule | undefined,\n  formData: Record<string, any>\n): boolean => {\n  if (!conditionalRequired) {\n    return baseRequired; // Use base required value if no conditional rule\n  }\n\n  const conditionMet = evaluateConditionalRule(conditionalRequired, formData);\n\n  // If action is 'require', return true when condition is met\n  // If action is 'optional', return false when condition is met\n  if (conditionalRequired.action === 'require') {\n    return conditionMet;\n  } else if (conditionalRequired.action === 'optional') {\n    return !conditionMet;\n  }\n\n  return baseRequired;\n};\n\n/**\n * Determine if a field should be disabled based on its conditional disabled rule\n */\nexport const isFieldDisabled = (\n  baseDisabled: boolean,\n  conditionalDisabled: ConditionalRule | undefined,\n  formData: Record<string, any>\n): boolean => {\n  if (!conditionalDisabled) {\n    return baseDisabled; // Use base disabled value if no conditional rule\n  }\n\n  const conditionMet = evaluateConditionalRule(conditionalDisabled, formData);\n\n  // If action is 'disable', return true when condition is met\n  // If action is 'enable', return false when condition is met\n  if (conditionalDisabled.action === 'disable') {\n    return conditionMet;\n  } else if (conditionalDisabled.action === 'enable') {\n    return !conditionMet;\n  }\n\n  return baseDisabled;\n};\n\n/**\n * Get all dependent field IDs from a conditional rule\n */\nexport const getDependentFieldIds = (rule: ConditionalRule | undefined): string[] => {\n  if (!rule || !rule.dependencies) {\n    return [];\n  }\n\n  return rule.dependencies.map(dep => dep.fieldId);\n};\n\n/**\n * Check if a field has any dependencies\n */\nexport const hasDependencies = (\n  conditionalVisibility?: ConditionalRule,\n  conditionalRequired?: ConditionalRule,\n  conditionalDisabled?: ConditionalRule\n): boolean => {\n  return !!(\n    (conditionalVisibility && conditionalVisibility.dependencies.length > 0) ||\n    (conditionalRequired && conditionalRequired.dependencies.length > 0) ||\n    (conditionalDisabled && conditionalDisabled.dependencies.length > 0)\n  );\n};","/**\n * Permission Checker Utility\n * Checks user permissions and roles for field access\n */\n\nimport type { FieldPermissions, UserPermissions } from '../types';\n\n/**\n * Check if user has required roles\n */\nexport const hasRequiredRoles = (\n  userRoles: string[],\n  requiredRoles?: string[]\n): boolean => {\n  if (!requiredRoles || requiredRoles.length === 0) {\n    return true; // No role requirement\n  }\n\n  return requiredRoles.some(role => userRoles.includes(role));\n};\n\n/**\n * Check if user has required permissions\n */\nexport const hasRequiredPermissions = (\n  userPermissions: Record<string, boolean>,\n  requiredPermissions?: string[]\n): boolean => {\n  if (!requiredPermissions || requiredPermissions.length === 0) {\n    return true; // No permission requirement\n  }\n\n  return requiredPermissions.every(permission => userPermissions[permission] === true);\n};\n\n/**\n * Determine field access mode based on permissions\n */\nexport const getFieldAccessMode = (\n  fieldPermissions: FieldPermissions | undefined,\n  userPermissions: UserPermissions\n): 'hidden' | 'view' | 'edit' => {\n  if (!fieldPermissions) {\n    return 'edit'; // Default to full access if no permissions defined\n  }\n\n  // Check if user has required roles\n  const hasRoles = hasRequiredRoles(userPermissions.roles, fieldPermissions.roles);\n\n  // Check if user has required permissions\n  const hasPerms = hasRequiredPermissions(\n    userPermissions.permissions,\n    fieldPermissions.permissions\n  );\n\n  // If user doesn't have required roles or permissions, use the defined mode or hide\n  if (!hasRoles || !hasPerms) {\n    return fieldPermissions.mode || 'hidden';\n  }\n\n  // User has access, return the specified mode or default to edit\n  return fieldPermissions.mode || 'edit';\n};\n\n/**\n * Check if field should be visible to user\n */\nexport const isFieldAccessible = (\n  fieldPermissions: FieldPermissions | undefined,\n  userPermissions: UserPermissions\n): boolean => {\n  const accessMode = getFieldAccessMode(fieldPermissions, userPermissions);\n  return accessMode !== 'hidden';\n};\n\n/**\n * Check if field should be read-only for user\n */\nexport const isFieldReadOnly = (\n  fieldPermissions: FieldPermissions | undefined,\n  userPermissions: UserPermissions\n): boolean => {\n  const accessMode = getFieldAccessMode(fieldPermissions, userPermissions);\n  return accessMode === 'view';\n};\n\n/**\n * Check if user can edit the form\n */\nexport const canEditForm = (\n  formPermissions: { requiredRoles?: string[]; requiredPermissions?: string[] },\n  userPermissions: UserPermissions\n): boolean => {\n  const hasRoles = hasRequiredRoles(userPermissions.roles, formPermissions.requiredRoles);\n  const hasPerms = hasRequiredPermissions(\n    userPermissions.permissions,\n    formPermissions.requiredPermissions\n  );\n\n  return hasRoles && hasPerms;\n};","/**\n * Core constants\n * @packageDocumentation\n */\n\nexport const FIELD_TYPES = {\n  TEXT: 'text',\n  EMAIL: 'email',\n  NUMBER: 'number',\n  DATE: 'date',\n  SELECT: 'select',\n  TEXTAREA: 'textarea',\n  CHECKBOX: 'checkbox',\n  RADIO: 'radio',\n  FILE: 'file',\n  TEL: 'tel',\n} as const;\n\nexport const VALIDATION_RULES = {\n  REQUIRED: 'required',\n  MIN_LENGTH: 'minLength',\n  MAX_LENGTH: 'maxLength',\n  PATTERN: 'pattern',\n  EMAIL: 'email',\n  MIN: 'min',\n  MAX: 'max',\n  CUSTOM: 'custom',\n} as const;\n\nexport const DEPENDENCY_OPERATORS = {\n  EQUALS: 'equals',\n  NOT_EQUALS: 'notEquals',\n  CONTAINS: 'contains',\n  GREATER_THAN: 'greaterThan',\n  LESS_THAN: 'lessThan',\n  IS_EMPTY: 'isEmpty',\n  IS_NOT_EMPTY: 'isNotEmpty',\n} as const;\n\nexport const CONDITIONAL_ACTIONS = {\n  SHOW: 'show',\n  HIDE: 'hide',\n  ENABLE: 'enable',\n  DISABLE: 'disable',\n  REQUIRE: 'require',\n  OPTIONAL: 'optional',\n} as const;\n\nexport const PERMISSION_MODES = {\n  VIEW: 'view',\n  EDIT: 'edit',\n  HIDDEN: 'hidden',\n} as const;\n\nexport const SUBMIT_STRATEGIES = {\n  FINAL_ONLY: 'final-only',\n  PER_STEP: 'per-step',\n} as const;\n\nexport const DEFAULT_AUTO_SAVE_INTERVAL = 5000; // 5 seconds\nexport const DEFAULT_ASYNC_VALIDATION_DEBOUNCE = 300; // 300ms","/**\n * @react-dynamic-forms/core\n * Core types and utilities for React Dynamic Forms\n * @packageDocumentation\n */\n\n// Export all types\nexport * from './types';\n\n// Export all utilities\nexport * from './utils';\n\n// Export constants\nexport * from './constants';\n\n// Package version\nexport const VERSION = '0.1.0';"]}